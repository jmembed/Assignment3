	   title     "Stopwatch Generator"
	   list      p=16f877a
	   include   "p16f877a.inc"

	__CONFIG _CP_OFF & _WDT_OFF & _BODEN_OFF & _PWRTE_ON & _HS_OSC & _WRT_OFF & _LVP_OFF & _CPD_OFF

; '__CONFIG' directive is used to embed configuration data within .asm file.
; The lables following the directive are located in the respective .inc file.
; See respective data sheet for additional information on configuration word.
; Remember there are TWO underscore characters before the word CONFIG.

;*******************************************************************
;
;  filename  ::   A fundamental stop watch with some additional features
;  ===================================
;
; Description
;    The stop watch will exhibit a start and stop button for the user to begin and end count
;	 A reset facility is also included with the current contents of count
;	 stored and displayed on reset
;	 A maximum count will reset the counter and begin counting again
;	 An alarm will sound when an alarm time is reached 
; 	 
;
;
; Method
;    When start button is pressed count will be initiated
;	 Check for maximum and alarm will be incorporated into count
;	 reset routine set up as an interrupt using RB0 as reset switch
;	 On stop, output displayed as hex value of the current counts 
;	 ascii character values
;
; Version
;    Michael Black and James McLay   V1.0    November 2013
;
; Project Log
;    14/11/13:		Code Began
;	 14/11/13:		Basic code structure set up
;	 15/11/13:		Functionality changed so stop press is ISR trigger
;
;******************************************************************* 
;*******************************************************************    
;
; Constant declarations
; =====================
;
MaxCount  	equ     	d'99'           ; Maximum Iterations of Count before reset
CountStep 	equ 		d'620'		    ; 1 count value (in ms) - may not be needed in code 
Base	  	equ			d'10' 			; BAse count value
Alarm		equ 		d'10'			; constant for now without switches 
;
;******************************************************************* 
;*******************************************************************    
;
; Variable declarations  : User RAM area starts at location h'20' for PIC16F877a
; =====================
;
w_temp		equ	h'7D'		; variable used for context saving 
status_temp	equ	h'7E'		; variable used for context saving
pclath_temp	equ	h'7F'		; variable used for context saving

Count	        equ     h'20'		; Decimal internal count to aid max/alarm check
Stop			equ 	h'21'		; Coutn value when stop is pressed
Units			equ 	h'22'		; Unit value for display count
Tens			equ		h'23' 		; Tens Value for display count

;
;*******************************************************************
;******************************************************************* 
; Initial system vector.
;   
	org     h'00'                   ; initialise system restart vector
	clrf 	STATUS
	clrf 	PCLATH			; needed for TinyBootloader functionality
	goto    start

;******************************************************************* 
;******************************************************************* 
; interrupt vector
;
	org	h'04'
	goto	int_routine

;******************************************************************* 
;******************************************************************* 
;
; System subroutines.
;  
	org     h'05'           ; start of program space
;
;******************************************************************* 
;******************************************************************* 
; System functions
;******************************************************************* 
;
;* Init : initialise I/O ports and variables
;  ====
; Notes
;      RB0 reset switch input 
;	   RA0 used as stop/start button
;
Init    
	bsf     STATUS, RP0        ; enable page 1 register set
	bcf		STATUS, RP1

	movlw	h'07'
	movwf	ADCON1		   ; set PORTA to be digital rather than analogue

	movlw   b'000011'
	movwf   TRISA              ; set port A  
	movlw   b'00000001'                 
	movwf   TRISB              ; set port B 
	movlw   b'00000011'                 
	movwf   TRISC              ; set port C 
	movlw   b'11111111'                 
	movwf   TRISD              ; set port D 
	bcf     STATUS, RP0        ; back to page 0 register set
;
; initialise program variables
;
;	clrf	variable1          ; ensure that no delay command is active

;
; configure RB0/INT interrupt.
;       1. Configure interrupt to occur on rising edge.
;       2. Set RB0/INT enable flag (INTE in INTCON)
;       3. enable global interrupts
;
	bsf     STATUS, RP0        ; enable page 1 register set 
    bsf     OPTION_REG,INTEDG  ; RB0 interrupt on rising edge for reset switch 
	bcf     STATUS, RP0        ; back to page 0 register set       

;
 
	bcf 	PORTC, 0		   ; ensure start stop trigger port is cleared

	return
;******************************************************************* 
;
;  int_routine : routine to handle the single interrupt
;  ===========
; Notes
;      Interrupt Routine carried out on Stop Push Button
;			- stores current value and displays ascii hex equivalent 
;			- restarts code to wait for start button
;
int_routine
	movwf   w_temp            ; save off current W register contents
	movf	STATUS,w          ; move status register into W register
	movwf	status_temp       ; save off contents of STATUS register
	movf	PCLATH,w	  	  ; move pclath register into w register
	movwf	pclath_temp	  	  ; save off contents of PCLATH register
;
;	MY INTERRUPT ROUTINE
; 	LapTime = Count;
	movf	Count, w		  ; 
	movwf 	Stop			  ; 
	
;DISPLAY STOP ON HEX


;	Goto start, Max Or Alarm used in same way as counter to return to start of program

Restart	equ 	b'1'	; MaxOrAlarm binary variable used to distinguish if counter ended due to alarm or max, or due to completetion of count
							; MaxOrAlarm = 1 - triggered by alarm or max count
							; MaxOrAlarm = 0 - count completed as usual

;
	movf	pclath_temp,w	  ; retrieve copy of PCLATH register
	movwf	PCLATH		  	; restore pre-isr PCLATH register contents
	movf    status_temp,w     ; retrieve copy of STATUS register
	movwf	STATUS            ; restore pre-isr STATUS register contents
	swapf   w_temp,f
	swapf   w_temp,w          ; restore pre-isr W register contents
	retfie 
;*******************************************************************    
;
; ****** other system subroutines.
;

counter

checkForMax
; check for max 
; 	if count == max
;		goto reset
; 	end
;
	movf 	MaxCount, w	;
	subwf 	Count		;
	btfsc	STATUS, Z	; if c bit is 0 then skip
	goto 	MaxNotReached
	call	ResetCount

Restart		equ 	b'1'				; MaxOrAlarm binary variable used to distinguish if counter ended due to alarm or max, or due to completetion of count
										; MaxOrAlarm = 1 - triggered by alarm or max count
										; MaxOrAlarm = 0 - count completed as usual

	return								; force return to start after max is reached

;*******************************************************************    
;						
MaxNotReached 
	
; check for alarm
; 		if count == alarm
;		generate alarm
;		end
;

	movf 	Alarm, w				
	subwf 	Count					
	btfsc	STATUS, Z				; if c bit is 0 then skip
	goto 	BeginCount
	call	Alarm


Restart 	equ 	b'1'			; MaxOrAlarm binary variable used to distinguish if counter ended due to alarm or max, or due to completetion of count
									; MaxOrAlarm = 1 - triggered by alarm or max count
									; MaxOrAlarm = 0 - count completed as usual

	return							; force return to start after alarm

;*******************************************************************    
;							 
BeginCount

; generate remaining time to complete one count and increment count

call delay

; units = units + 1; 
;if units=Base 
;	units = 0;
; 	Base = Base + 1; 
;else
;	units = units + 1; 

	incf	Units, f		;
	
	movf 	Units, f		; 
	sublw	Base			;
	btfss	STATUS, Z		; 
	goto 	ifelse 			; 
	incf	Tens, f			; 
	movlw	d'0'
	movwf	Units	

ifelse 
	incf	Units, f		; 

;MaxOrAlarm 	equ		b'0'; 

	return 	
;			
;******************************************************************* 
ResetCount

return
;*******************************************************************   
delay

return
;*******************************************************************  
;
; MAIN program
; ============
;
start   
    call    Init

start1 
 
;	if start(RA0)==0
;		goto loop
;	else
;		while (RESET(also RA0)==0)
;			call counter
;		end 
;	end
;	
;	display current count value

	bcf     INTCON,INTE        ; disable RB0/INT interrupt while start/ reset bit checks

loop
	btfsc	PORTC, 0 			; check reset trigger	
	goto	RESETCOUNT			
	goto 	STARTCHECK

RESETCOUNT
	call 	ResetCount
	goto	loop

STARTCHECK
	btfss	PORTC, 1
	goto 	loop			; check again


	bsf     INTCON,INTE        ; enable RB0/INT interrupt

countloop			
	call 	counter
	movf	Restart, w	; MaxOrAlarm to w reg 
	btfsc	STATUS, Z		; if z bit is 0 then skip
	goto	start
	goto 	countloop
	

;
;******************************************************************* 
;
; Program complete.
;
	END


