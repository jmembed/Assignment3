	   title     "Stopwatch Generator"
	   list      p=16f877a
	   include   "p16f877a.inc"

	__CONFIG _CP_OFF & _WDT_OFF & _BODEN_OFF & _PWRTE_ON & _HS_OSC & _WRT_OFF & _LVP_OFF & _CPD_OFF

; '__CONFIG' directive is used to embed configuration data within .asm file.
; The lables following the directive are located in the respective .inc file.
; See respective data sheet for additional information on configuration word.
; Remember there are TWO underscore characters before the word CONFIG.

;*******************************************************************
;
;  filename  ::   A fundamental stop watch with some additional features
;  ===================================
;
; Description
;    The stop watch will exhibit a start and stop button for the user to begin and end count
;	 A reset facility is also included with the current contents of count
;	 stored and displayed on reset
;	 A maximum count will reset the counter and begin counting again
;	 An alarm will sound when an alarm time is reached 
; 	 
;
; Method
;    When start button is pressed count will be initiated
;	 Check for maximum and alarm will be incorporated into count
;	 reset routine set up as an interrupt using RB0 as reset switch
;	 On stop, output displayed as hex value of the current counts 
;	 ascii character values
;
; Version
;    Michael Black and James McLay   V1.0    November 2013
;
; Project Log
;    14/11/13:		Code Began
;	 14/11/13:		Basic code structure set up
;	 15/11/13:		Functionality changed so stop press is ISR trigger
;	 21/11/13:		Serial Data Output Added
;					- Added HexUnits and HexSixteens Count to aid
;	 22/11/13		Delay added;
;					Tested Hex Count Ascii Representation
; 	 25/11/13		Serial Data Output not Working 
;					Protocol fixed 
;	 26/11/13		Alarm control by switches Added
;					Output to oscilloscope on stop Added
;					Lap Counter Extra Feature Added 
;					Small Delay to accomodate Ascii Output
;
;******************************************************************* 
;*******************************************************************    
;
; Constant declarations
; =====================
;
MaxCount  	equ     	d'99'           ; Maximum Iterations of Count before reset 
Base	  	equ			d'10' 			; BAse count value
AsciiInteger	equ		d'48'			; where ascii characters representing integer values starts
AsciiChar	equ			d'65'			; where ascii characters representing numbers start
;
;******************************************************************* 
;*******************************************************************    
;
; Variable declarations  : User RAM area starts at location h'20' for PIC16F877a
; =====================
;
w_temp		equ	h'7D'		; variable used for context saving 
status_temp	equ	h'7E'		; variable used for context saving
pclath_temp	equ	h'7F'		; variable used for context saving

Count	        equ     h'20'		; Decimal internal count to aid max/alarm check
HexUnits		equ		h'21'		; Hex value to aid hex count output
HexSixteens		equ		h'22'		; Hex value of count to aid output
Units			equ 	h'23'		; Unit value for display count
Tens			equ		h'24' 		; Tens Value for display count
counter			equ		h'25'		; counter used for serial data output
temp			equ		h'26'		; temp variable value
Data1			equ		h'27'		; first ascii hex count
Data2			equ		h'28'		; second ascii hex count
delpar			equ		h'29'		; big delay
delcnt1			equ		h'30'		; small delay
delcnt2			equ		h'31'		; medium delay
Restart			equ 	h'32'		; Restart variable that is 1 to force system restart
temp2			equ		h'33'		; temp 2 variable to hold output subtracted value
HexOut1			equ		h'34'		; 8 bit data representing ascii hex count value 
HexOut2			equ 	h'35'		; 8 bit data representing ascii hex count value 
HexOutTemp1		equ		h'36'		; temporarily holds hex output for oscilloscope
HexOutTemp2		equ		h'37'		; temporarily holds hex output for oscilloscope
delcnt3			equ		h'38'		; internal delay for 100ns delay
Alarm			equ		h'39'		; ALARM VAriable value 
;
;*******************************************************************
;******************************************************************* 
; Initial system vector.
;   
	org     h'00'                   ; initialise system restart vector
	clrf 	STATUS
	clrf 	PCLATH			; needed for TinyBootloader functionality
	goto    start

;******************************************************************* 
;******************************************************************* 
; interrupt vector
;
	org	h'04'
	goto	int_routine

;******************************************************************* 
;******************************************************************* 
;
; System subroutines.
;  
	org     h'05'           ; start of program space
;
;******************************************************************* 
#DEFINE 	SERIALOUT		PORTC, 2; RC2 is serial output bit
#DEFINE 	CLK				PORTC, 1; RC1 is clock
#DEFINE 	CE				PORTC, 0; RC0 is chip enable
;******************************************************************* 
; System functions
;******************************************************************* 
;
;* Init : initialise I/O ports and variables
;  ====
; Notes
;      RB0  stop switch input 
;	   RB1, RB2 used as reset and start respectively 
;		RB4 is used as lap counter to output lap to seven seg
;	   RC0 used as output from microcontroller to enable 7 seg dispaly
; 	   RC1 used as output from microcontroller for clock
;	   RC2 used as output from microcontroller for 16 bit serial data to 7 seg display
;	   RB3 used as output to oscilloscope
;	   PORTD 8 bit alarm value
;
Init    
	bsf     STATUS, RP0        ; enable page 1 register set
	bcf		STATUS, RP1

	movlw	h'07'
	movwf	ADCON1		   ; set PORTA to be digital rather than analogue

	movlw   b'000011'
	movwf   TRISA              ; set port A  
	movlw   b'00010111'                 
	movwf   TRISB              ; set port B, RB0,1,2 and 4 used as inputs
	movlw   b'00000000'                 
	movwf   TRISC              ; set port C, all outputs
	movlw   b'11111111'                 
	movwf   TRISD              ; set port D all as inputs 
	bcf     STATUS, RP0        ; back to page 0 register set

;
; initialise program variables
;
;	clrf	variable1          ; ensure that no delay command is active
;
;***********************************************************************
;
; configure RB0/INT interrupt.
;       1. Configure interrupt to occur on rising edge.
;       2. Set RB0/INT enable flag (INTE in INTCON)
;       3. enable global interrupts (done in main)
;
	bsf     STATUS, RP0        ; enable page 1 register set 
    bsf     OPTION_REG,INTEDG  ; RB0 interrupt on rising edge for reset switch 
	bcf     STATUS, RP0        ; back to page 0 register set     

	bsf     INTCON,INTE        ; enable RB0/INT interrupt  

   ; ensure start stop trigger port is cleared
	bcf 	PORTB, 0	;stop		
	bcf		PORTB, 1	;reset
	bcf		PORTB, 2	;start

	;ensure enable bit is high, i.e. disabled		   
	bsf		CE
	
	;ensure data in is low
	bcf 	SERIALOUT

	movlw	b'0'
	movwf	Restart

	call 	ResetCount

	return
;******************************************************************* 
;
InitSevenSeg

; 	SHUT DOWN Set to normal op
	movlw	h'0C'
	movwf	Data1
	movlw	h'01'
	movwf	Data2
	call	OutputCount

; set display test normal op
	movlw	h'0F'
	movwf	Data1
	movlw	h'00'
	movwf	Data2
	call	OutputCount
		
;decode mode on 
	movlw	h'09'
	movwf	Data1
	movlw	h'0F'
	movwf	Data2
	call	OutputCount

;scan data
	movlw	h'0B'
	movwf	Data1
	movlw	h'03'
	movwf	Data2
	call	OutputCount

	return

;******************************************************************* 
;
;  int_routine : routine to handle the single interrupt
;  ===========
; Notes
;      Interrupt Routine carried out on Stop Push Button
;			- stores current value and displays ascii hex equivalent 
;			  by outputting serially to portB
;			- restarts code to wait for start button
;
int_routine
	movwf   w_temp            ; save off current W register contents
	movf	STATUS,w          ; move status register into W register
	movwf	status_temp       ; save off contents of STATUS register
	movf	PCLATH,w	  	  ; move pclath register into w register
	movwf	pclath_temp	  	  ; save off contents of PCLATH register
;
;******************************************************************* 	
;	MY INTERRUPT ROUTINE
;******************************************************************* 	
;
; set 8 bit data values representing ascii characters
; as hex count could be represented by a letter or an integer in ascii
; this must be accounted for
;
;******************************************************************* 	
;HexOut1 Set
;******************************************************************* 
; if HexUnits < 10; 			we have integer
;	HexOut1 = HexUnits + 48;  	Ascii Integer start point plus units
; else
;	HexOut1 = HexUnits + (65-10); 		Ascii Num Start Point plus (units-10)
	
	movlw	d'10'
	movwf	temp
	movf	temp, w
	subwf	HexUnits,w 
	btfsc	STATUS,C
	goto 	ifelse

; store ascii integer in temp to be added to HexUnits
	movlw	AsciiInteger
	movwf	temp
	movf	HexUnits, w
	addwf	temp,w		;store result in w reg+
	movwf	HexOut1
	goto	setData2	

ifelse  
	movf    HexUnits, w
	sublw	d'10'
	movwf	temp2				; subtracted value
	movlw	AsciiChar
	movwf	temp
	movf	temp2, w
	addwf	temp,w				;store result in w reg+
	movwf	HexOut1

;******************************************************************* 	
;HexOut2 Set
;******************************************************************* 
;
; if HexSixteens< 10; 			we have integer
;	HexOut2 = HexSixteens+ 48;  	Ascii Integer start point plus units
; else							we have letter A-F
;	HEXoUT2 = HexSixteens + 65-10; 		Ascii Num Start Point plus units

setData2
	movlw	d'10'
	movwf	temp
	movf	temp, w
	subwf	HexSixteens,w 
	btfsc	STATUS,C
	goto 	ifelse

; store ascii integer in temp to be added to HexUnits
	movlw	AsciiInteger
	movwf	temp
	movf	HexSixteens, w
	addwf	temp,w		;store result in w reg+
	movwf	HexOut2
	goto	display	

ifelse2 
	movf    HexSixteens, w
	sublw	d'10'
	movwf	temp2				; subtracted value
	movlw	AsciiChar
	movwf	temp
	movf	temp2, w
	addwf	temp,w		;store result in w reg+
	movwf	HexOut2

display

	call 	OutputAscii

;	ensure return to start after interrupt
	movlw	b'1'							; restart binary variable used to distinguish if counter ended due to alarm or max, or due to completetion of count
	movwf	Restart							; restart = 1 - triggered by alarm or max count
											; Restart = 0 - count completed as usual

	bcf     INTCON,INTF   					; clear interrupt flag

	movf	pclath_temp,w	  				; retrieve copy of PCLATH register
	movwf	PCLATH		  					; restore pre-isr PCLATH register contents
	movf    status_temp,w     				; retrieve copy of STATUS register
	movwf	STATUS            				; restore pre-isr STATUS register contents
	swapf   w_temp,f
	swapf   w_temp,w          				; restore pre-isr W register contents
	retfie 

;*******************************************************************    
;
; ****** other system subroutines.
;
Counter

checkForMax
; check for max 
; 	if count == max
;		goto reset
; 	end
;
	movlw	MaxCount
	movwf	temp
	movf 	Count, w	
	subwf 	temp,w 		
	btfss	STATUS, Z						; if c bit is 0 then skip
	goto 	MaxNotReached
	call	ResetCount

	movlw	b'1'							; restart binary variable used to distinguish if counter ended due to alarm or max, or due to completetion of count
	movwf	Restart							; restart = 1 - triggered by alarm or max count
											; Restart = 0 - count completed as usual

	return									; force return to start after max is reached

;*******************************************************************    
;						
MaxNotReached 
	
; check for alarm
;		ALARM = PORTC
; 		if count == alarm
;		generate alarm
;		end
;
	movf    PORTD, w                     ; load PORTB to Wreg	
	movwf	Alarm					 	; PORTB value stored in readout

	movf	Alarm, w
	movwf	temp
	movf 	Count, w	
	subwf 	temp,w 						
	btfss	STATUS, Z						; if c bit is 0 then skip
	goto 	BeginCount
	call	alarmFunction
	call	ResetCount
 
	movlw	b'1'							; restart binary variable used to distinguish if counter ended due to alarm or max, or due to completetion of count
 	movwf	Restart							; restart = 1 - triggered by alarm or max count
											; Restart = 0 - count completed as usual

	return									; force return to start after alarm

;*******************************************************************    
;							 
BeginCount

; generate remaining time to complete one count and increment count

	movlw	d'62'
	movwf	delpar

	call delay

; if interrupt has occurred we must not increment count
; check restart to skip 

	movf	Restart, w			; Restart to w reg 
	btfss	STATUS, Z			; if z bit is 0 then skip
	goto 	exitInt

; Base ten counting 
; units = units + 1; 
;if units=Base 
;	units = 0;
; 	Base = Base + 1; 
;else
;	exit; 

	incf	Units, f		;
	
	movf	Units, w
	sublw	Base			;
	btfss	STATUS, Z		; 
	goto 	SEVENSEG			; 
	incf	Tens, f			; 
	clrf	Units		;

SEVENSEG

	call 	InitSevenSeg

;output data
	movlw	h'01'
	movwf	Data1
	movf	Units, w
	movwf	Data2
	call	OutputCount


	movlw	h'02'
	movwf	Data1
	movf	Tens, w
	movwf	Data2
	call	OutputCount

; Hex count to aid stop output
; same functionality as tens and units but units resets when 16

	incf	HexUnits, f		;
	
	movf 	HexUnits, w
	sublw	d'16' 			;
	btfss	STATUS, Z		; 
	goto 	exitCount			; 
	incf	HexSixteens, f			; 
	movlw	d'0'
	movwf	HexUnits	
	goto 	exitCount

exitCount

	incf	Count

exitInt
	return 	
;			
;******************************************************************* 	
;Output Count
;******************************************************************* 
; enable bit low to enable sendign data

; TYPICAL C code for generic 16 bits of serial data
; Data1 = 0000 (4 bit value representing address)
; Data2 = 8 bit data value (could represent count if address is for a display) 
; for (n = 0; n=7; n++) {
;	SerialOut = DATA1(0); 
;	clk = 1
;	may need wait!!
;	clk = 0
;	shift data1 right
; 	}
;
; repeat for data 2
;
;SOME DATA 
;******************************************************************* 	
;Set Decode Mode Reg DATA 
;******************************************************************* 

; Data1 = 00001001 (ADDRESS)
; Data2 = 11111111 (DATA)
OutputCount

	bcf		CE; 				; Enable = 0; 
	
	clrf	counter; 

serialoutput
	movlw	d'8'	
	subwf	counter, w	 
	btfsc	STATUS,Z
	goto 	forexit

; check next readout bit value and set PORTC to output correct value
; if DATA bit0 = 0
; 		serialOut = 0; 
;else
;		serialOut = 1; 

	btfss	Data1, 7
	goto	BITCLEAR
	goto	BITSET

BITCLEAR
	bcf 	SERIALOUT 
	goto 	jump

BITSET
	bsf		SERIALOUT

jump	
;shift right 8 bit number so next clock high sends next bit
	rlf		Data1, f				; shift unit reg right 

;pulse clock to send PORTC bit 2 serially
	bsf		CLK
	nop
	nop
	nop
	nop
	bcf		CLK

	incf	counter
	goto	serialoutput

forexit

	clrf	counter

serialoutput2
	movlw	d'8'	
	subwf	counter,w	 
	btfsc	STATUS,Z
	goto 	forexit2

; check next readout bit value and set PORTC to output correct value
; if DATA bit0 = 0
; 		serialOut = 0; 
;else
;		serialOut = 1; 

	btfss	Data2, 7
	goto	BITCLEAR2
	goto	BITSET2

BITCLEAR2
	bcf 	SERIALOUT 
	goto 	jump2

BITSET2
	bsf		SERIALOUT

jump2	
;shift right 8 bit number so next clock high sends next bit
	rlf		Data2, f				; shift unit reg right 

;pulse clock to send PORTC bit 2 serially
	bsf		CLK
	bcf		CLK

	incf	counter
	goto	serialoutput2

forexit2

	bsf		CE; 				; Enable = 0; 

	return
;
;*******************************************************************   
;
ResetCount
; set overall count, units and tens to 0
	clrf	Count
	clrf	Units
	clrf	Tens
	clrf	HexUnits
	clrf	HexSixteens

	call 	InitSevenSeg

	movlw	h'01'
	movwf	Data1
	movlw	d'0'
	movwf	Data2
	call	OutputCount

	movlw	h'02'
	movwf	Data1
	movlw 	d'0'
	movwf	Data2
	call	OutputCount

	return
;
;*******************************************************************   
;
; 100ns delay function
;
Delay100ns	
	movlw	d'31'
	movwf	delcnt3
	nop
	nop
repeat
	decfsz	delcnt3,F
	goto	repeat

	return

;
;*******************************************************************   
;
; Main delay that is 0.01 seconds * input of delpar
;
delay	
	movlw	d'10'
	movwf	delcnt1
	movlw	d'189'	
	movwf	delcnt2

delay1
delay2
	nop
	decfsz	delcnt2,F
	goto	delay2
	decfsz	delcnt1,F
	goto	delay1

	decfsz	delpar,F
	goto	delay	
	
	return
;
;*******************************************************************   
;
; generates 100Hz Frequency output to oscilloscope from PORTB bit 4
; i.e. 10ms pulses x 500 for 5second buzz
; for (0:500: counter++){
;	Pulse = 1;
; 	wait(500)
;	pulse = 0; 
;	}

alarmFunction	

	clrf	counter; 

alarmPulse
	
	movlw	d'250'	
	subwf	counter, w	 
	btfsc	STATUS,Z
	goto 	alarmComplete

	bsf		PORTB, 4
	
	movlw	d'1'
	movwf	delpar
	call 	delay
	
	bcf		PORTB, 4
	
	movlw	d'1'
	movwf	delpar
	call 	delay
	
	incf	counter
	goto 	alarmPulse
			   
alarmComplete	

	return
;
;*******************************************************************  
; This function takes in the ascii equivalent of hex count 
; and outputs serially to PORTB Bit 3 at 9600 Baud
; 
;The process ends when the reset bit is pressed stream is stopped
; ; for (n = 0; n=7; n++) {
;	PORTB, 3 = HexOut1(0)
;	wait 0.1ms
;	shift HexOut1 right
; 	}
;
; ; for (n = 0; n=7; n++) {
;	PORTB, 3 = HexOut2(0)
;	wait 0.1ms
;	shift HexOut2 right
; 	}
OutputAscii 

	clrf	counter

outBegin
; check next HexOut1 value and set PORTB bit 3 to output correct value
; if HexOut1(0) = 0
; 		serialOut = 0; 
;else
;		serialOut = 1; 

	movfw	HexOut1
	movwf	HexOutTemp1
	movfw	HexOut2
	movwf	HexOutTemp2

OutputNextBit	

	movlw	d'8'	
	subwf	counter,w	 
	btfsc	STATUS,Z
	goto 	OutComplete
	btfss	HexOutTemp1, 0
	goto	ClearOutputCount
	goto	SetOutputCount

ClearOutputCount
	bcf 	PORTB, 3 
	goto 	exitOut

SetOutputCount
	bsf 	PORTB, 3 

exitOut 

;shift right 8 bit number so next clock high sends next bit
	rrf		HexOutTemp1, f				; shift unit reg right 

	call	Delay100ns	; delay 0.1ms to retain baud rate of 9600b/s

	incf	counter
	goto	OutputNextBit

OutComplete

	clrf	counter

OutputNextBit2

; check next HexOut1 value and set PORTB bit 3 to output correct value
; if HexOut1(0) = 0
; 		serialOut = 0; 
;else
;		serialOut = 1; 

	movlw	d'8'	
	subwf	counter,w	 
	btfsc	STATUS,Z
	goto 	OutComplete2
	btfss	HexOutTemp2, 0
	goto	ClearOutputCount2
	goto	SetOutputCount2

ClearOutputCount2
	bcf 	PORTB, 3 
	goto 	exitOut2

SetOutputCount2
	bsf 	PORTB, 3 

exitOut2 

;shift right 8 bit number so next clock high sends next bit
	rrf		HexOutTemp2, f				; shift unit reg right 
	
	call	Delay100ns	; delay 0.1ms to retain baud rate of 9600b/s	

	incf	counter
	goto	OutputNextBit2

 OutComplete2
	
;	Check reset Bit to stop output stream and restart code
	btfss	PORTB, 1
	goto 	outBegin

	return
;
;*******************************************************************  
DisplayLap

	call 	InitSevenSeg

;output data
	movlw	h'03'
	movwf	Data1
	movf	Units, w
	movwf	Data2
	call	OutputCount


	movlw	h'04'
	movwf	Data1
	movf	Tens, w
	movwf	Data2
	call	OutputCount

	return
;
;*******************************************************************  
;
; MAIN program
; ============
;
start   
    call    Init

start1 
; Restart = 0 

	movlw	b'0'							; restart binary variable used to distinguish if counter ended due to alarm or max, or due to completetion of count
 	movwf	Restart							; restart = 1 - triggered by alarm or max count
											; Restart = 0 - count completed as usual

;	if start(RB2)==0
;		goto loop
;	else
;		while (STOP==0)
;			call counter
;		end 
;	end
;	
;	display current count value
	bcf     INTCON,GIE    ; | disable global interrupts

loop
	btfsc	PORTB, 1 			; check reset trigger	
	goto	RESETCOUNT			
	goto 	STARTCHECK

RESETCOUNT
	call 	ResetCount
	goto	loop

STARTCHECK
	btfss	PORTB, 2
	goto 	loop				; check again
	bsf       INTCON,GIE    ; | enable global interrupts


countloop			
 	call 	Counter
	btfsc	PORTB, 1			; check for lap counter
	goto 	lapCounter
	movf	Restart, w			; Restart to w reg 
	btfss	STATUS, Z			; if z bit is 0 then skip			
	goto	start1
	goto 	countloop

lapCounter
	call 	DisplayLap
	call	ResetCount
	goto 	countloop

;
;******************************************************************* 
;
; Program complete.
;
	END


